# HTTP(HyperText Transfer Protocol)

- 서버와 클라이언트가 텍스트, 이미지, 동영상 등의 데이터를 주고받을 때 사용하는 프로토콜

- 데이터를 안전하게 주고받기 위해 HTTP에 전송 계층 보안(Transport Layer Security)을 더해 만든 HTTPS 프로토콜 사용

## 무상태성

- stateless 프로토콜 : 요청 메시지를 보내기 직전까지 대상 컴퓨터가 연결 가능한지 메시지를 응답할 수 있는 상태인지 알 방법이 없음

  - TCP(Transmission Control Protocol)는 stateful로 연결을 끊지않고 명시적으로 연결을 닫기 전까지 계속 메시지 주고 받음

- HTTP는 TCP 프로토콜 기반에 텍스트 기반의 HTTP 헤더와 메시지까지 사용하기 때문에 패킷 크기가 상대적으로 큼

- HTTP는 로직 간단하지만 TCP보다 느림. TCP는 상대적으로 빠르지만 연결 상태를 직접 관린해야 해서 로직이 복잡함.

- 대부분 웹 서비스는 메시지 통신 처리 시간보다 기능 로직 처리 시간이 더 길어서 프로토콜 바꾸는 건 큰 차이 없음.

  - TCP는 실시간 멀티플레이 게임이나 금융 서비스처럼 1초 사이 주고 받는 데이터량이 많아서 메시지 처리 시간이 로직 처리보다 오래 걸리는 경우에만 사용하는 게 좋음.

## HTTP 요청

### 요청 메서드(GET, POST, DELETE 등)

- 요청 메서드는 요청의 형태를 정의

#### **GET**

- 웹 브라우저가 서버에 웹 페이지 요청할 때 사용

- 읽기 요청이므로 메시지 바디를 넣을 수 없음

- 요청 주소에 ?와 & 구분자 사용하여 쿼리 파라미터 추가

#### **POST**

- 클라이언트에서 서버로 데이터가 포함된 요청 보낼 때 사용

#### **DELETE**

- 데이터 삭제 시 사용

#### **PUT**

- 이미 존재하는 데이터의 업데이트 요청

### URL(Uniform Resource Locator)

- 웹 주소, 요청 주소로 HTTP에서 통신할 대상 컴퓨터 식별할 때 사용

- 사람이 기억하기 쉽게 만든 식별자

- 두 컴퓨터가 실제 통신할 때는 IP를 사용하므로 통신 위해서 DNS(도메인 네임 시스템) 통해서 URL을 IP주소로 변환하는 작업 필요

- 하나의 URL이 여러 IP 주소 가질 수 있음

  - DNS 라운드 로빈/DNS 로드 밸런싱 : 클라이언트가 IP주소 요청 시 DNS가 여러 IP주소 중 하나를 보내주어 서버 부하 줄임

- +) URI(Uniform Resource Identifier)는 특정 문서, 영상 등과 같은 자원의 위치를 가리킬 때 사용

### HTTP 버전

- 1.1 버전은 1.0 버전 보다 효율적 연결 위해 소켓 재사용 요청하는 keep-alive 헤더 추가와 언어 및 인코딩 지원을 위한 헤더 등 추가

- 1.1 버전은 하나의 요청에 하나의 응답만 보낼 수 있음

- 2.0버전은 웹페이지 하나를 보기 위해 수십 번 요청하는 문제 해결하고 한 번의 요청에 수십 개의 응답을 병렬로 보낼 수 있도록 개선하고 불필요한 오버헤드 제거

### 요청 헤더

#### **Host 헤더**

- URL 경로 제외한 주소가 저장됨.

- 포트 번호도 저장 가능하지마 필수 정보 아님.

- 포트 번호가 없으면 기보 포트 번호인 80(HTTP)이나 443(HTTPS) 사용

#### **Accept 헤더**

- 클라이언트가 처리할 수 있는 데이터 형태 알려주는 키워드 저장

- Accept-Encoding, Accept-Language, Accept-Charset 등

  - Accept-Encoding: 클라이언트가 처리 가능한 압축 방식 지정하며 DEFLATE나 gzip 사용

  - Accept-Language: 클라리언트가 처리 가능한 언어를 지정 (한국어, 영어 등)

  - Accept-Charset: 클라이언트가 처리할 수 있는 문자 집합 지정(대부분 UTF-8)

#### **User-Agent 헤더**

- HTTP 요청이 발생한 웹 브라우저 프로그램 정보 저장

- 브라우저별로 사용하는 User-Agent값 전체 목록은 https://developers.whatismybrower.com/useragents/explore/ 에서 확인 가능

- User-Agent 헤더를 가져올 때는 운영체제, 브라우저 종류, 버전 정보에 따라 값이 바뀔 수 있음

- 구글은 User-Agent에 운영체제 정보 등 불필요한 값이 너무 많고 마케팅 용도로 사용자 추적 시 사생활 침해 우려가 있어 점진적으로 사용하지 않고 폐기하기로 함. 디버깅과 브라우저 사용 현황 추적에 필요한 정보만 담아 Client Hint 헤더에 넣을 것이라고 함.

#### **Content-Type 헤더**

- 메시지 바디의 형식을 알 수 있는 키워드 포함

- Content-Type에 따라 브라우저 동작이 바뀔 수 있음

  - ex. Content-Type이 application/json이면 크로스 사이트 요청 위조(CSRF)/JSON 하이재킹을 막기 위해 자바스크립트 실행을 막음

#### **Content-Length 헤더**

- HTTP 헤더를 제외한 바디 데이터의 길이를 담는 헤더

- 메시지 바디가 없는 GET 메서드일 경우 헤더 값은 0

#### **Connection:keep-alive**

- HTTP 1.1 버전부터 지원

- 요청/응답마다 소켓 연결을 끟는 비효율적 수조를 개서하기 위하 헤더 정보

- keep-alive 설정 시 요청 받은 서버는 응답 보낸 후 타임아웃 시간 전까지 소켓 연결을 끊지 않음

### 메시지 바디

- 실질적인 요청 데이터 담는 데 사용

- 단순 문자열 외 이미지, 동영상, 파일과 같은 바이너리 저장 가능

  - HTTP로 바이너리 보낼 때는 Base64로 인코딩

- GET, OPTIONS 메서드는 서버의 상태를 변경하지 않고 데이터 요청할 때만 사용하는 메서드이므로 메시지 바디 사용할 수 없음. 서버로 보내야할 정보가 생기면 파라미터를 넣어 요청 가능.

## HTTP 응답

- 첫 줄에 HTTP 버전, 상태 코드, 상태 메시지가 차례대로 표시됨

### 상태 코드와 메시지

- 요청 정상적으로 처리하면 서버는 코드 200과 OK를 응답으로 보냄. 201, 202 등은 큰 의미로 200과 같고 세부적인 내용만 다름.

- 2xx 코드는 성공 의미 메시지

- 3xx 코드는 서버 이동(redirection) 메시지

- 4xx 코드는 잘못되 인수를 넣어 요청한 것으로 요청을 보낸 클라이언트에서 수정 필요하다는 메시지

- 5xx 코드는 서버 내부 에러로 클라이언트가 할 수 있는 건 없고 서버 문제

## 세션과 쿠키

- HTTP 웹 서버는 쿠키와 세션ID를 통해 클라이언트 구분 가능

- 쿠키를 사용하면 클라이언트가 새 요청 보낸 것인지 이전에 보낸 요청이 있었는지 구분 가능

- 세션 ID와 같은 쿠키 정보 오래 가지고 있으면 메모리 할당 외에 잠재적으로 생길 수 있는 쿠키 탈취 등 여러 보안 문제 발생 가능하므로 쿠키 생성 시 만료 시간 지정

- HTTP 응답에 Max-Age와 Expires 값은 쿠키 만료 시간 의미

- 쿠키를 이용한 대표적인 공격 방법은 세션 가로채기, XSS나 CSRF와 같은 스크립트 삽입 등이 있음

- 해킹 공격 방지하기 위해 쿠기 보호 가능한 HTTPS 필수 사용해야 하고 HTTP 접속해도 HTTPS로 접속하도록 서버 이동 처리하는 게 좋음

- 저장된 정보를 남이 봐도 안전한지에 따라 쿠키에 저장해도 되는 정보인지 판단 가능

- 서버 프로그램은 항상 쿠키는 언제든지 변조될 수 있다는 사실을 염두에 두고 개발해야 함

- 유럽연합 일반 데이터 보호 규칙(GDPR)을 충족하기 위해서는 쿠키에서 수집한 정보가 무엇인지 구체적으로 공개하고 동의를 구해야 하고, 수집 거부 시 불이익도 없어야 함

- 쿠키 설정 시 Secure 옵션 추가하면 HTTPS 통신할 때만 쿠키를 서버로 전송

- HttpOnly 옵션 추가하면 웹 브라우저에서 자바스크립트를 통해 쿠키에 접근하는 것을 방지 가능

## 스티키 세션

- 수평적 확장은 서버의 하드웨어 업그레이드하는 대신 더 많은 서버를 추가 확장하는 것

- 로드밸런스 서비스는 사용자가 접속했을 때 부하가 가장 적은 웹 서버로 연결해주고 동작하지 않는 서버를 발견하면 서버 목록에서 자동으로 제외

- 로드밸런스 서비스를 통해 접속 서버가 바뀌면 쿠키나 세션 정보가 사라질 수 있는데 스티키 세션 활성화하면 하나의 브라우저는 하나의 웹서버에만 연결

  - 쿠키 없는 요청 들어오면 쿠키에 값 등록하고 웹서버 지정한 후 이후 요청으 세션 값 기준으로 다시 연결할 웹 서버 구분

  - 세션 유지 기간을 함께 설정하는데, 이 때 쿠키 만료 시간보다 길게 설정

## 교차 출처 리소스 공유(CORS)

- 교차 출처 리소스 공유(cross-origin resource sharing)는 HTTP 서버의 웹 페이지, 이미지 파일이나 API 등을 특정 호스트로 접속한 웹 브라우저만 사용할 수 있게 제한하는 정책

- 동일 출처 정책(same origin policy)는 사전에 지정하지 않은 다른 곳에서 웹 페이지, API와 같은 리솟 요청 차단하는 방어 장치

- CORS 단순 요청은 요청 정보가 간단해 별다른 보안 검증이 필요하지 않는 교차 출처 리소스 공유 의미

  - GET, HEAD, POST 메서드 사용하는 경우

  - POST 메서드일 때 Content-Type 헤더가 'text/plain', 'application/x-www-form-urlenceded', 'multipart/form-data' 중 하나인 경우

  - 표준에 정의되지 않은 사용자 헤더를 쓰지 않는 경우

- CORS 사전 요청은 추가적은 보안 검증이 필요한 요청으로 단순 요청 적용할 수 없는 경우

  - 사전 요청 헤더

    - Origin: 요청을 하는 웹 페이지 도메인을 지정

    - Access-Control-Request-Method: 교차 도메인으로 보낼 요청의 메서드 지정

    - Access-Control-Request-Headers: 교차 도메인으로 보낼 요청 사용자 정의 헤더 지정. 표준에 정의된 헤더만 사용한다면 이 헤더 보내지 않아도 됨.

  - 사전 요청 응답 헤더

    - Access-Control-Allow-Origin: 단순 요청과 동일하게 와일드카드(\*)를 포함한 도메인이나 서브 도메인 목록 보여줌

    - Access-Control-Allow-Methods: 허용 가능한 메서드 목록

    - Access-Control-Allow-Headers: 허용 가능한 사용자 정의 헤더 목록. 요청 시 사용자 정의 헤더가 포함된 경우에만 반환.
