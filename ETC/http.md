# HTTP(HyperText Transfer Protocol)

- 서버와 클라이언트가 텍스트, 이미지, 동영상 등의 데이터를 주고받을 때 사용하는 프로토콜

- 데이터를 안전하게 주고받기 위해 HTTP에 전송 계층 보안(Transport Layer Security)을 더해 만든 HTTPS 프로토콜 사용

## 무상태성

- stateless 프로토콜 : 요청 메시지를 보내기 직전까지 대상 컴퓨터가 연결 가능한지 메시지를 응답할 수 있는 상태인지 알 방법이 없음

  - TCP(Transmission Control Protocol)는 stateful로 연결을 끊지않고 명시적으로 연결을 닫기 전까지 계속 메시지 주고 받음

- HTTP는 TCP 프로토콜 기반에 텍스트 기반의 HTTP 헤더와 메시지까지 사용하기 때문에 패킷 크기가 상대적으로 큼

- HTTP는 로직 간단하지만 TCP보다 느림. TCP는 상대적으로 빠르지만 연결 상태를 직접 관린해야 해서 로직이 복잡함.

- 대부분 웹 서비스는 메시지 통신 처리 시간보다 기능 로직 처리 시간이 더 길어서 프로토콜 바꾸는 건 큰 차이 없음.

  - TCP는 실시간 멀티플레이 게임이나 금융 서비스처럼 1초 사이 주고 받는 데이터량이 많아서 메시지 처리 시간이 로직 처리보다 오래 걸리는 경우에만 사용하는 게 좋음.

## HTTP 요청

### 요청 메서드(GET, POST, DELETE 등)

- 요청 메서드는 요청의 형태를 정의

#### **GET**

- 웹 브라우저가 서버에 웹 페이지 요청할 때 사용

- 읽기 요청이므로 메시지 바디를 넣을 수 없음

- 요청 주소에 ?와 & 구분자 사용하여 쿼리 파라미터 추가

#### **POST**

- 클라이언트에서 서버로 데이터가 포함된 요청 보낼 때 사용

#### **DELETE**

- 데이터 삭제 시 사용

#### **PUT**

- 이미 존재하는 데이터의 업데이트 요청

### URL(Uniform Resource Locator)

- 웹 주소, 요청 주소로 HTTP에서 통신할 대상 컴퓨터 식별할 때 사용

- 사람이 기억하기 쉽게 만든 식별자

- 두 컴퓨터가 실제 통신할 때는 IP를 사용하므로 통신 위해서 DNS(도메인 네임 시스템) 통해서 URL을 IP주소로 변환하는 작업 필요

- 하나의 URL이 여러 IP 주소 가질 수 있음

  - DNS 라운드 로빈/DNS 로드 밸런싱 : 클라이언트가 IP주소 요청 시 DNS가 여러 IP주소 중 하나를 보내주어 서버 부하 줄임

- +) URI(Uniform Resource Identifier)는 특정 문서, 영상 등과 같은 자원의 위치를 가리킬 때 사용

### HTTP 버전

- 1.1 버전은 1.0 버전 보다 효율적 연결 위해 소켓 재사용 요청하는 keep-alive 헤더 추가와 언어 및 인코딩 지원을 위한 헤더 등 추가

- 1.1 버전은 하나의 요청에 하나의 응답만 보낼 수 있음

- 2.0버전은 웹페이지 하나를 보기 위해 수십 번 요청하는 문제 해결하고 한 번의 요청에 수십 개의 응답을 병렬로 보낼 수 있도록 개선하고 불필요한 오버헤드 제거

### 요청 헤더

#### **Host 헤더**

- URL 경로 제외한 주소가 저장됨.

- 포트 번호도 저장 가능하지마 필수 정보 아님.

- 포트 번호가 없으면 기보 포트 번호인 80(HTTP)이나 443(HTTPS) 사용

#### **Accept 헤더**

- 클라이언트가 처리할 수 있는 데이터 형태 알려주는 키워드 저장

- Accept-Encoding, Accept-Language, Accept-Charset 등

  - Accept-Encoding: 클라이언트가 처리 가능한 압축 방식 지정하며 DEFLATE나 gzip 사용

  - Accept-Language: 클라리언트가 처리 가능한 언어를 지정 (한국어, 영어 등)

  - Accept-Charset: 클라이언트가 처리할 수 있는 문자 집합 지정(대부분 UTF-8)

#### **User-Agent 헤더**

- HTTP 요청이 발생한 웹 브라우저 프로그램 정보 저장

- 브라우저별로 사용하는 User-Agent값 전체 목록은 https://developers.whatismybrower.com/useragents/explore/ 에서 확인 가능

- User-Agent 헤더를 가져올 때는 운영체제, 브라우저 종류, 버전 정보에 따라 값이 바뀔 수 있음

- 구글은 User-Agent에 운영체제 정보 등 불필요한 값이 너무 많고 마케팅 용도로 사용자 추적 시 사생활 침해 우려가 있어 점진적으로 사용하지 않고 폐기하기로 함. 디버깅과 브라우저 사용 현황 추적에 필요한 정보만 담아 Client Hint 헤더에 넣을 것이라고 함.

#### **Content-Type 헤더**

- 메시지 바디의 형식을 알 수 있는 키워드 포함

- Content-Type에 따라 브라우저 동작이 바뀔 수 있음

  - ex. Content-Type이 application/json이면 크로스 사이트 요청 위조(CSRF)/JSON 하이재킹을 막기 위해 자바스크립트 실행을 막음

#### **Content-Length 헤더**

- HTTP 헤더를 제외한 바디 데이터의 길이를 담는 헤더

- 메시지 바디가 없는 GET 메서드일 경우 헤더 값은 0

#### **Connection:keep-alive**

- HTTP 1.1 버전부터 지원

- 요청/응답마다 소켓 연결을 끟는 비효율적 수조를 개서하기 위하 헤더 정보

- keep-alive 설정 시 요청 받은 서버는 응답 보낸 후 타임아웃 시간 전까지 소켓 연결을 끊지 않음

### 메시지 바디

- 실질적인 요청 데이터 담는 데 사용

- 단순 문자열 외 이미지, 동영상, 파일과 같은 바이너리 저장 가능

  - HTTP로 바이너리 보낼 때는 Base64로 인코딩

- GET, OPTIONS 메서드는 서버의 상태를 변경하지 않고 데이터 요청할 때만 사용하는 메서드이므로 메시지 바디 사용할 수 없음. 서버로 보내야할 정보가 생기면 파라미터를 넣어 요청 가능.

## HTTP 응답

- 첫 줄에 HTTP 버전, 상태 코드, 상태 메시지가 차례대로 표시됨

### 상태 코드와 메시지

- 요청 정상적으로 처리하면 서버는 코드 200과 OK를 응답으로 보냄. 201, 202 등은 큰 의미로 200과 같고 세부적인 내용만 다름.

- 2xx 코드는 성공 의미 메시지

- 3xx 코드는 서버 이동(redirection) 메시지

- 4xx 코드는 잘못되 인수를 넣어 요청한 것으로 요청을 보낸 클라이언트에서 수정 필요하다는 메시지

- 5xx 코드는 서버 내부 에러로 클라이언트가 할 수 있는 건 없고 서버 문제
